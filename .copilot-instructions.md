# Copilot Instructions for Mobile Base Project

## Project Overview

This project focuses on creating comprehensive mobile development foundations spanning cross-platform and native implementations. The goal is to build reusable, scalable, and maintainable mobile architecture patterns.

## Architecture Principles

### 1. Cross-Platform First Approach

- Prioritize cross-platform solutions while maintaining native performance
- Use platform-specific implementations only when necessary
- Maintain clear abstraction layers between platforms

### 2. Clean Architecture Implementation

- Follow Clean Architecture principles with clear layer separation
- Domain layer should be completely independent of external frameworks
- Use dependency inversion to maintain testability
- Implement proper error handling and validation at each layer

### 3. MVVM Pattern Guidelines

- Models should be immutable data structures
- ViewModels handle business logic and state management
- Views should be passive and only handle UI rendering
- Use data binding for reactive UI updates

## Code Standards

### File Organization

```
project/
├── core/
│   ├── domain/          # Business entities and use cases
│   ├── data/           # Data sources and repositories
│   └── presentation/   # ViewModels and UI logic
├── platform/
│   ├── android/        # Android-specific implementations
│   ├── ios/           # iOS-specific implementations
│   └── shared/        # Cross-platform shared code
└── features/
    └── [feature-name]/
        ├── domain/
        ├── data/
        └── presentation/
```

### Naming Conventions

#### Classes and Interfaces

- **Entities**: `User`, `Product`, `Order`
- **Use Cases**: `GetUserUseCase`, `CreateOrderUseCase`
- **Repositories**: `UserRepository`, `ProductRepository`
- **ViewModels**: `UserViewModel`, `ProductListViewModel`
- **Data Sources**: `UserRemoteDataSource`, `UserLocalDataSource`

#### Files and Directories

- Use kebab-case for directories: `user-management/`, `product-catalog/`
- Use PascalCase for class files: `UserRepository.kt`, `ProductViewModel.swift`
- Use camelCase for utility files: `networkUtils.ts`, `dateHelper.kt`

### Testing Standards

#### Test File Naming

- Unit tests: `UserRepository.test.kt`, `ProductViewModel.test.swift`
- Integration tests: `UserRepository.integration.test.kt`
- UI tests: `LoginScreen.ui.test.kt`

#### Test Structure

- Follow AAA pattern: Arrange, Act, Assert
- Use descriptive test names: `should_return_user_when_valid_id_provided`
- Mock external dependencies
- Test both success and failure scenarios

## Security Guidelines

### Data Protection

- Encrypt sensitive data at rest
- Use secure communication protocols (HTTPS, certificate pinning)
- Implement proper authentication and authorization
- Follow platform-specific security best practices

### Privacy Compliance

- Implement GDPR compliance helpers
- Handle user consent properly
- Provide data anonymization utilities
- Maintain audit logs for compliance

## Performance Standards

### Memory Management

- Avoid memory leaks through proper lifecycle management
- Use weak references where appropriate
- Implement efficient caching strategies
- Monitor memory usage and optimize accordingly

### Battery Optimization

- Minimize background processing
- Use efficient networking patterns
- Implement proper wake lock management
- Optimize for platform-specific power management

## Development Workflow

### Branch Strategy

- `main`: Production-ready code
- `develop`: Integration branch for features
- `feature/[feature-name]`: Individual feature development
- `hotfix/[issue-description]`: Critical bug fixes

### Commit Messages

Follow conventional commits:

- `feat: add user authentication system`
- `fix: resolve memory leak in image cache`
- `docs: update API documentation`
- `refactor: improve error handling in network layer`

### Code Review Guidelines

- Ensure architecture compliance
- Check for security vulnerabilities
- Verify test coverage
- Validate performance implications
- Review documentation completeness

## Platform-Specific Guidelines

### Android

- Follow Material Design guidelines
- Use Kotlin coroutines for async operations
- Implement proper lifecycle management
- Follow Android architecture component patterns

### iOS

- Follow Human Interface Guidelines
- Use Swift's modern concurrency features
- Implement proper memory management
- Follow iOS design patterns (Coordinator, VIPER)

### Cross-Platform

- Maintain platform parity in core features
- Use shared business logic
- Implement platform-specific UI adaptations
- Ensure consistent user experience

## Documentation Requirements

### Code Documentation

- Document public APIs with clear examples
- Include parameter descriptions and return values
- Provide usage examples for complex components
- Document architectural decisions and trade-offs

### Architecture Decision Records (ADRs)

- Document significant architectural decisions
- Include context, options considered, and rationale
- Update when decisions change or evolve
- Maintain decision history for reference

## When Helping with Code

### Always Consider

- Is this following our Clean Architecture principles?
- Does this maintain platform compatibility?
- Is this properly tested and testable?
- Does this follow our security guidelines?
- Is this performant and memory-efficient?

### Code Generation Guidelines

- Generate complete, working implementations
- Include proper error handling
- Add comprehensive documentation
- Provide usage examples
- Consider edge cases and validation

### Refactoring Approach

- Maintain existing functionality
- Improve code structure and readability
- Enhance testability
- Optimize performance where possible
- Update documentation accordingly
